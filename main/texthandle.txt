import stardog
import pandas as pd
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import plotly.express as px

# Connection details
conn_details = {
    'endpoint': 'http://localhost:5820',  # Replace with your Stardog endpoint
    'username': 'admin',                  # Replace with your Stardog username
    'password': 'admin'                   # Replace with your Stardog password
}

database_name = 'your_database_name'  # Replace with your Stardog database name

def execute_query(query, label_column):
    with stardog.Connection(database_name, **conn_details) as conn:
        results = conn.select(query)
    
    data = results
    variables = data['head']['vars']
    bindings = data['results']['bindings']
    rows = []

    for binding in bindings:
        row = {}
        for var in variables:
            if var in binding:
                value = binding[var]['value']
                # Convert numerical values
                if binding[var]['type'] == 'literal' and 'datatype' in binding[var]:
                    datatype = binding[var]['datatype']
                    if datatype in (
                        'http://www.w3.org/2001/XMLSchema#decimal',
                        'http://www.w3.org/2001/XMLSchema#float',
                        'http://www.w3.org/2001/XMLSchema#double',
                        'http://www.w3.org/2001/XMLSchema#integer',
                        'http://www.w3.org/2001/XMLSchema#int',
                    ):
                        value = float(value)
                row[var] = value
            else:
                row[var] = None
        rows.append(row)
    
    df = pd.DataFrame(rows)
    df['total_revenue_gap'] = pd.to_numeric(df['total_revenue_gap'])
    df = df.sort_values('total_revenue_gap', ascending=False)
    return df

def get_customer_data():
    query = """
    PREFIX : <http://api.stardog.com/>
    PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
    SELECT ?customer_name (ROUND(SUM(?revenue_gap_value) * 1000) / 1000 AS ?total_revenue_gap)
    WHERE {
      # Retrieve the IBE that contains the customer name
      ?ibe_cust :has_text_value ?customer_name .
      ?designative_name_customer :generically_depends_on ?ibe_cust .
      ?designative_name_customer :designates ?customer .
      ?customer rdf:type :Customer_Organization .

      # Retrieve the revenue gap associated with the customer
      ?revenue_gap :is_about ?customer .

      # Retrieve the measurement of the revenue gap
      ?measurement :is_measurement_of ?revenue_gap .
      ?measurement :generically_depends_on ?ibe_rev_gap_value .

      # Get the revenue gap value
      ?ibe_rev_gap_value :has_decimal_value ?revenue_gap_value_literal .
      BIND(xsd:decimal(?revenue_gap_value_literal) AS ?revenue_gap_value)
    }
    GROUP BY ?customer_name
    ORDER BY DESC(?total_revenue_gap)
    """
    return execute_query(query, 'customer_name')

def get_aircraft_data():
    query = """
    PREFIX : <http://api.stardog.com/>
    PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
    SELECT ?aircraft_model_name (ROUND(SUM(?revenue_gap_value) * 1000) / 1000 AS ?total_revenue_gap)
    WHERE {
      {
        SELECT DISTINCT ?aircraft_model_name ?revenue_gap ?revenue_gap_value
        WHERE {
          # Ensure we're dealing with aircraft models
          ?artifact_identifier_aircraft_model rdf:type :Designative_Information_Content_Entity .
          ?artifact_identifier_aircraft_model :designates ?aircraft_model .
          ?aircraft_model rdf:type :Artifact_Model .
          ?artifact_identifier_aircraft_model :generically_depends_on ?ibe_aircraft_model .
          ?ibe_aircraft_model :has_text_value ?aircraft_model_name .
          FILTER(STRSTARTS(STR(?aircraft_model), STR(:aircraft_model_)))

          # Aircraft model prescribes part aggregates
          ?aircraft_model :prescribes ?part_aggregate .

          # Part aggregate bears revenue gaps
          ?part_aggregate :bearer_of ?revenue_gap .

          # Retrieve the measurement of the revenue gap
          ?measurement :is_measurement_of ?revenue_gap .
          ?measurement :generically_depends_on ?ibe_rev_gap_value .

          # Get the revenue gap value
          ?ibe_rev_gap_value :has_decimal_value ?revenue_gap_value_literal .
          BIND(xsd:decimal(?revenue_gap_value_literal) AS ?revenue_gap_value)
        }
      }
    }
    GROUP BY ?aircraft_model_name
    ORDER BY DESC(?total_revenue_gap)
    """
    return execute_query(query, 'aircraft_model_name')

def get_engine_data():
    query = """
    PREFIX : <http://api.stardog.com/>
    PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
    SELECT ?engine_model_name (ROUND(SUM(?revenue_gap_value) * 1000) / 1000 AS ?total_revenue_gap)
    WHERE {
      {
        SELECT DISTINCT ?engine_model_name ?revenue_gap ?revenue_gap_value
        WHERE {
          # Ensure we're dealing with engine models
          ?artifact_identifier_engine_model rdf:type :Designative_Information_Content_Entity .
          ?artifact_identifier_engine_model :designates ?engine_model .
          ?engine_model rdf:type :Artifact_Model .
          ?artifact_identifier_engine_model :generically_depends_on ?ibe_engine_model .
          ?ibe_engine_model :has_text_value ?engine_model_name .
          FILTER(STRSTARTS(STR(?engine_model), STR(:engine_model_)))

          # Exclude "N/A" values
          FILTER(?engine_model_name != "N/A" && ?engine_model_name != "")

          # Engine model prescribes part aggregates
          ?engine_model :prescribes ?part_aggregate .

          # Part aggregate bears revenue gaps
          ?part_aggregate :bearer_of ?revenue_gap .

          # Retrieve the measurement of the revenue gap
          ?measurement :is_measurement_of ?revenue_gap .
          ?measurement :generically_depends_on ?ibe_rev_gap_value .

          # Get the revenue gap value
          ?ibe_rev_gap_value :has_decimal_value ?revenue_gap_value_literal .
          BIND(xsd:decimal(?revenue_gap_value_literal) AS ?revenue_gap_value)
        }
      }
    }
    GROUP BY ?engine_model_name
    ORDER BY DESC(?total_revenue_gap)
    """
    return execute_query(query, 'engine_model_name')

def get_part_number_data():
    query = """
    PREFIX : <http://api.stardog.com/>
    PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
    SELECT ?part_number (ROUND(SUM(?revenue_gap_value) * 1000) / 1000 AS ?total_revenue_gap)
    WHERE {
      {
        SELECT DISTINCT ?part_number ?revenue_gap ?revenue_gap_value
        WHERE {
          # Ensure we're dealing with part models
          ?artifact_identifier_part_model rdf:type :Designative_Information_Content_Entity .
          ?artifact_identifier_part_model :designates ?part_model .
          ?part_model rdf:type :Artifact_Model .
          ?artifact_identifier_part_model :generically_depends_on ?ibe_part_model .
          ?ibe_part_model :has_text_value ?part_number .
          FILTER(STRSTARTS(STR(?part_model), STR(:part_model_)))

          # Part model prescribes part aggregates
          ?part_model :prescribes ?part_aggregate .

          # Part aggregate bears revenue gaps
          ?part_aggregate :bearer_of ?revenue_gap .

          # Retrieve the measurement of the revenue gap
          ?measurement :is_measurement_of ?revenue_gap .
          ?measurement :generically_depends_on ?ibe_rev_gap_value .

          # Get the revenue gap value
          ?ibe_rev_gap_value :has_decimal_value ?revenue_gap_value_literal .
          BIND(xsd:decimal(?revenue_gap_value_literal) AS ?revenue_gap_value)
        }
      }
    }
    GROUP BY ?part_number
    ORDER BY DESC(?total_revenue_gap)
    """
    return execute_query(query, 'part_number')

def create_bar_chart(df, label_column, title):
    fig = px.bar(
        df,
        x=label_column,
        y='total_revenue_gap',
        labels={'total_revenue_gap': 'Total Revenue Gap', label_column: label_column.replace('_', ' ').title()},
        title=title,
    )
    fig.update_traces(
        text=df['total_revenue_gap'].apply(lambda x: f"${x:,.2f}"),
        textposition='outside',
        marker_color='indianred',
    )
    fig.update_layout(
        xaxis_tickangle=-45,
        yaxis_tickformat='$,',
        uniformtext_minsize=8,
        uniformtext_mode='hide',
        plot_bgcolor='rgba(0,0,0,0)',
        hovermode='x',
        margin=dict(l=50, r=50, t=80, b=150),
    )
    return fig

app = dash.Dash(__name__)
server = app.server  # For deployment

app.layout = html.Div([
    html.H1('Total Revenue Gap Analysis', style={'textAlign': 'center'}),
    dcc.Tabs(id='tabs', value='customer', children=[
        dcc.Tab(label='Customer-wise', value='customer'),
        dcc.Tab(label='Aircraft-wise', value='aircraft'),
        dcc.Tab(label='Engine-wise', value='engine'),
        dcc.Tab(label='Part Number-wise', value='part_number'),
    ]),
    html.Div(id='tabs-content')
])

@app.callback(Output('tabs-content', 'children'),
              Input('tabs', 'value'))
def render_content(tab):
    if tab == 'customer':
        df = get_customer_data()
        label_column = 'customer_name'
        title = 'Total Revenue Gap per Customer'
    elif tab == 'aircraft':
        df = get_aircraft_data()
        label_column = 'aircraft_model_name'
        title = 'Total Revenue Gap per Aircraft Model'
    elif tab == 'engine':
        df = get_engine_data()
        label_column = 'engine_model_name'
        title = 'Total Revenue Gap per Engine Model'
    elif tab == 'part_number':
        df = get_part_number_data()
        label_column = 'part_number'
        title = 'Total Revenue Gap per Part Number'
    else:
        return html.Div('Tab not found.')
    
    fig = create_bar_chart(df, label_column, title)
    return dcc.Graph(figure=fig)

if __name__ == '__main__':
    app.run_server(debug=True)
